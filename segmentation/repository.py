"""
SQLAlchemy model and repository for persisting cluster segmentation results.

No clustering logic or business rules live here.
Alembic-compatible declarative model; all writes are transaction-safe.
"""

import uuid
from datetime import datetime, timezone
from typing import Optional

from sqlalchemy import DateTime, Index, Integer, String, func
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import DeclarativeBase, Mapped, Session, mapped_column


# ------------------------------------------------------------------
# Declarative base
# (shared across models if other modules import and extend Base)
# ------------------------------------------------------------------

class Base(DeclarativeBase):
    pass


# ------------------------------------------------------------------
# Model
# ------------------------------------------------------------------

class SegmentInsight(Base):
    """
    Persisted snapshot of a segmentation run for one entity / period.

    Columns:
        id:           Primary key (UUID v4), generated by the application.
        entity_name:  Identifier for the customer / account being segmented.
                      Indexed for fast lookup.
        period_end:   ISO-8601 date string marking the end of the analysis
                      window (e.g. "2024-12-31"). Indexed for time-range
                      queries.
        n_clusters:   Number of clusters used in this run.
        segment_data: Full cluster profiles as JSONB (labels, metrics, etc.).
        created_at:   UTC timestamp set by the database on insert.
    """

    __tablename__ = "segment_insights"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    entity_name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        index=True,
    )
    period_end: Mapped[str] = mapped_column(
        String(10),          # "YYYY-MM-DD"
        nullable=False,
        index=True,
    )
    n_clusters: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
    )
    segment_data: Mapped[dict] = mapped_column(
        JSONB,
        nullable=False,
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    # Composite index for the common query pattern: entity + period
    __table_args__ = (
        Index("ix_segment_insights_entity_period", "entity_name", "period_end"),
    )

    def __repr__(self) -> str:
        return (
            f"<SegmentInsight id={self.id} entity={self.entity_name!r} "
            f"period_end={self.period_end!r} n_clusters={self.n_clusters}>"
        )


# ------------------------------------------------------------------
# Repository
# ------------------------------------------------------------------

class SegmentInsightRepository:
    """
    Data-access layer for ``SegmentInsight`` records.

    All methods accept an active SQLAlchemy ``Session``; the caller
    controls transaction boundaries (commit / rollback).

    Not responsible for:
        - Clustering or feature engineering.
        - Business labeling.
        - Session lifecycle management.
    """

    def save_segments(
        self,
        session: Session,
        entity_name: str,
        period_end: str,
        n_clusters: int,
        segment_data: dict,
    ) -> SegmentInsight:
        """
        Persist a new segmentation snapshot.

        Args:
            session:      Active SQLAlchemy session.
            entity_name:  Entity identifier (e.g. account name or ID).
            period_end:   Period end date string ("YYYY-MM-DD").
            n_clusters:   Number of clusters used in this run.
            segment_data: Cluster profiles dict to store as JSONB.

        Returns:
            The newly created ``SegmentInsight`` instance (not yet committed).
        """
        record = SegmentInsight(
            id=uuid.uuid4(),
            entity_name=entity_name,
            period_end=period_end,
            n_clusters=n_clusters,
            segment_data=segment_data,
        )
        session.add(record)
        return record

    def get_latest_segments(
        self,
        session: Session,
        entity_name: str,
        period_end: Optional[str] = None,
    ) -> Optional[SegmentInsight]:
        """
        Retrieve the most recent segmentation snapshot for an entity.

        Args:
            session:      Active SQLAlchemy session.
            entity_name:  Entity to look up.
            period_end:   Optional filter; if provided, restrict to this
                          period end date string.

        Returns:
            The latest ``SegmentInsight`` row, or ``None`` if not found.
        """
        query = (
            session.query(SegmentInsight)
            .filter(SegmentInsight.entity_name == entity_name)
        )

        if period_end is not None:
            query = query.filter(SegmentInsight.period_end == period_end)

        return (
            query
            .order_by(SegmentInsight.created_at.desc())
            .first()
        )
